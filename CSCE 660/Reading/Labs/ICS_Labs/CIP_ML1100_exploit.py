#!/usr/bin/env python

import socket
import os
import sys
import time
import string
from optparse import OptionParser
from optparse import OptionGroup
import struct

class ENIP:

	def connect(self, ip, port, slot):
		self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.sock.connect((ip, port))	
		self.register_session()
		self.slot = slot
		self.context = 0
		
	def send(self, packet):
		self.sock.send(packet)
		
	def recv(self):
		return self.sock.recv(65536)

	def register_session (self):

		reg = '65000400000000000000000000000000000000000000000001000000'.decode('hex')
		self.send(reg)
	
		response = self.recv()
		self.session = response[4:8]
	
		return self.session

	def wrapENIPHeader(self, cmd_spc_data, command='\x70\x00'):
	
		self.context = 0
		context = struct.pack('<Q', self.context)
		leng = struct.pack('<H', len(cmd_spc_data))
		status = '\x00'*4
		options = '\x00\x00\x00\x00'
	
		header = command + leng + self.session + status + context + options
		return header + cmd_spc_data


	def wrapCIPHeader(self, data):
		hdr = '000000000a00020000000000b200'.decode('hex')
		
		pkt = '4b0220672401'.decode('hex') + data
		
		pkt = hdr + struct.pack('<H', len(pkt)) + pkt
		
		return pkt
		



parser = OptionParser()

# Change the default IP address to that of your PLC
parser.add_option('-i', '--ip', dest='ip', help='IP address of PLC', default='192.168.107.3', type='string', metavar='IP')
parser.add_option('-p', '--port', dest='port', default=44818, help='TCP port to connect to (default=44818)', type='int', metavar='INT')

parser.add_option('-t', '--test', dest='test', help='Test', action='store_true', default=False)

parser.add_option('-P', '--prog', dest='prog', help='Put the PLC in program mode (assuming key is in REM position)', action='store_true', default=False)
parser.add_option('-r', '--run', dest='run', help='Put the PLC in run mode (assuming key is in REM position)', action='store_true', default=False)

parser.add_option('-f', '--forcelow', dest='forcelow', help='ForceLow', action='store_true', default=False)
parser.add_option('-F', '--forcehigh', dest='forcehigh', help='ForceHigh', action='store_true', default=False)

(options, args) = parser.parse_args()

e = ENIP()
e.connect(options.ip, options.port, 0)


# Set this to True if you have CIP packets instead of ENIP
IS_CIP = False



# Queries for status of PLC
if options.test:
	print e.session.encode('hex')
	cmd_spc_data = '0000000003000200850010003139322e3136382e3130372e32303300910005000600080003'.decode(
	'hex')
	
	p = cmd_spc_data
	p = e.wrapENIPHeader(p, '\x6F\x00')
	
	e.send(p)
	print e.recv()

	
# Forces output 0 (O:0.0/5) low
if options.forcelow:
#Update the data field with appropriate content from your Wireshark capture
	cmd_spc_data = ''.decode('hex')
	p = cmd_spc_data
	
	# If we need to wrap it in CIP, wrap it first
	if IS_CIP:
		p = e.wrapCIPHeader(p)
	
	p = e.wrapENIPHeader(p, '\x6F\x00')
	e.send(p)
	print e.recv()

# Forces output 0 (O:0.0/5) high
if options.forcehigh:
#Update the data field with appropriate content from your Wireshark capture
	cmd_spc_data = ''.decode('hex')
	p = cmd_spc_data
	
	# If we need to wrap it in CIP, wrap it first
	if IS_CIP:
		p = e.wrapCIPHeader(p)
	
	p = e.wrapENIPHeader(p, '\x6F\x00')
	e.send(p)
	print e.recv()

# Forces PLC into Program Mode
if options.prog:
#Update the data field with appropriate content from your Wireshark capture
	cmd_spc_data = ''.decode('hex')
	p = cmd_spc_data
	
	# If we need to wrap it in CIP, wrap it first
	if IS_CIP:
		p = e.wrapCIPHeader(p)
	
	p = e.wrapENIPHeader(p, '\x6F\x00')
	e.send(p)
	print e.recv()

# Forces PLC into Run Mode	
if options.run:
#Update the data field with appropriate content from your Wireshark capture
	cmd_spc_data = ''.decode('hex')
	p = cmd_spc_data
	
	# If we need to wrap it in CIP, wrap it first
	if IS_CIP:
		p = e.wrapCIPHeader(p)
	
	p = e.wrapENIPHeader(p, '\x6F\x00')
	e.send(p)
	print e.recv()
		



